#include "IRGen.hpp"

std::string stabs = "std::shared_ptr<Object> apiWrapperPrint(std::shared_ptr<Object> o) {\n\
	objPrint(o);\n\
	return std::make_shared<Object>();\n\
}\n\
\n\
std::map<std::string, std::function<std::shared_ptr<Object>(std::shared_ptr<Object>)> > API = {\n\
	{\"console.log\",apiWrapperPrint}\n\
};\n";
std::string header = "#include <iostream>\n#include <functional>\n#include <map>\n#include <deque>\n#include <stack>\n#include <boost/any.hpp>\nclass Object\n{\npublic:\n	std::string tag = \"undefined\";\n	bool isFunction = false;\n	int functionID = -1;\n	std::map<std::string, std::shared_ptr<Object>> scope;\n	std::stack<std::map<std::string, std::shared_ptr<Object>>> recurstack;\n	std::pair<std::shared_ptr<Object>, Object *> prototype = {nullptr, this};\n	std::map<std::string, std::shared_ptr<Object>> member;\n	std::deque<std::shared_ptr<Object>> list;\n	Object *__scope__ = nullptr;\n	std::pair<std::shared_ptr<Object>, Object *> __proto__;\n	boost::any value;\n	std::shared_ptr<Object> __ret__ = nullptr;\n	int reentrant = 0;\n 	Object() = default;\n	~Object() = default;\n\n	virtual std::shared_ptr<Object> apply(std::shared_ptr<Object> __this__ = nullptr, std::shared_ptr<Object> e = nullptr) {\n		return nullptr;\n	}\n\n	virtual std::shared_ptr<Object> newObj(std::shared_ptr<Object> e = nullptr) {\n		std::shared_ptr<Object> ret = std::make_shared<Object>();\n		ret->tag = \"disc\";\n		if(this->prototype.first == nullptr) {\n			this->prototype.first = std::make_shared<Object>();\n			this->prototype.first->tag = \"disc\";\n		}\n		ret->__proto__ = this->prototype;\n		this->apply(ret, e);\n		return ret;\n	}\n\n	template<typename T>\n	std::shared_ptr<Object> newFunc(int funcID) {\n			__ret__ = std::make_shared<T>();\n			__ret__->tag = \"Function\";\n			__ret__->isFunction = true;\n			__ret__->functionID = funcID;\n			__ret__->__scope__ = this;\n			return __ret__;\n	}\n\n};\n\nstd::shared_ptr<Object>& brackets(std::shared_ptr<Object> o, std::string name) {\n	if(o == nullptr || o->tag == \"undefined\") {\n		std::cerr<<\"RUNTIME ERROR: cannot modify undefined\"<<std::endl;\n		exit(1);\n	}\n	if(o->tag != \"disc\") {\n		std::cerr<<\"RUNTIME ERROR: only disc has member\"<<std::endl;\n		exit(1);\n	}\n	Object *tryfind = o.get();\n	if(name != \"prototype\" && name != \"proto\") {\n		while(tryfind != nullptr) {\n			try {\n				if(tryfind->member.find(name) != tryfind->member.end()) {\n					return tryfind->member.at(name);\n				}\n				else\n				{\n					tryfind = tryfind->__proto__.first.get();\n					continue;\n				}\n			}\n			catch(...)\n			{\n				break;\n			}\n		}\n		\n		o->member[name] = std::make_shared<Object>();\n		return o->member.at(name);\n	}\n	else if(name == \"prototype\") {\n		if(o->prototype.first == nullptr) {\n			o->prototype.first = std::make_shared<Object>();\n			//o->prototype.first->tag = \"disc\";\n		}\n		return o->prototype.first;\n	}\n	\n	return o->__proto__.first;\n}\n\nstd::shared_ptr<Object>& brackets(std::shared_ptr<Object> o, double i) {\n	if(o->tag != \"list\") {\n		std::cerr<<\"RUNTIME ERROR: only list has index\"<<std::endl;\n		exit(1);\n	}\n	try {\n		return o->list.at(i);\n	}\n	catch(...)\n	{\n		std::cerr<<\"RUNTIME ERROR: out of range\"<<std::endl;\n		exit(1);\n	}\n}\n\nstd::shared_ptr<Object>& brackets(std::shared_ptr<Object> o, std::shared_ptr<Object> p) {\n	if(p->tag == \"double\")\n	{\n		return brackets(o, boost::any_cast<double>(p->value));\n	}\n	else if(p->tag == \"string\")\n	{\n		return brackets(o, boost::any_cast<std::string>(p->value));\n	}\n	std::cerr<<\"RUNTIME ERROR: in [] only support string and double type \"<<std::endl;\n	exit(1);\n}\n\nstd::shared_ptr<Object> listwith() {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"list\";\n	return ret;\n}\n\ntemplate<typename T, typename ...Args>\nstd::shared_ptr<Object> listwith(T t, Args ...args) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"list\";\n	std::shared_ptr<Object> to;\n	objBind(to, t);\n	ret = listwith(args...);\n	ret->list.push_front(to);\n	return ret;\n}\n\ntemplate<typename ...Args>\nstd::shared_ptr<Object> listwith(std::shared_ptr<Object> t, Args ...args) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"list\";\n	ret = listwith(args...);\n	ret->list.push_front(t);\n	return ret;\n}\n\ntemplate<>\nstd::shared_ptr<Object> listwith(std::shared_ptr<Object> t) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"list\";\n	ret->list.push_front(t);\n	return ret;\n}\n\ntemplate<typename T>\nstd::shared_ptr<Object> listwith(T t) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"list\";\n	std::shared_ptr<Object> to;\n	objBind(to, t);\n	ret->list.push_front(to);\n	return ret;\n}\n\nstatic void objBind(std::shared_ptr<Object>& o, double i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"double\";\n	ret->value = i;\n	o = ret;\n}\n\nstatic void objBind(std::shared_ptr<Object>& o, std::string i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"string\";\n	ret->value = i;\n	o = ret;\n}\n\nstatic void objBind(std::shared_ptr<Object>& o, bool i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = \"bool\";\n	ret->value = i;\n	o = ret;\n}\n\nstatic void objBind(std::shared_ptr<Object>& o, const std::shared_ptr<Object>& n) {\n	o = n;\n}\n\nstatic void renewScope(Object *func, std::shared_ptr<Object> var, std::string name, int level = 0, bool isAlloc = false) {\n	if(isAlloc) {\n		func->scope[name] = var;\n		return;\n	}\n	int i = 0;\n	Object *trace = func;\n	while(i < level) {\n		trace = trace->__scope__;\n		if(trace == nullptr) {\n			std::cerr<<\"RUNTIME ERROR: \"<<name<<\" in no scope, cannot be renewed \"<<std::endl;\n			return;\n		}\n		i++;\n	}\n	trace->scope[name] = var;\n}\n\nstatic std::shared_ptr<Object>& objFetch(Object *func, std::string name, int level = 0) {\n	int i = 0;\n	Object *trace = func;\n	while(i < level) {\n		trace = trace->__scope__;\n		if(trace == nullptr) {\n			std::cerr<<\"RUNTIME ERROR: \"<<name<<\" in no scope, cannot be fetched \"<<std::endl;\n			exit(1);\n		}\n		i++;\n	}\n	return trace->scope[name];\n}\n\nstatic std::shared_ptr<Object> objAdd(std::shared_ptr<Object> o, double i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = boost::any_cast<double>(o->value) + i;\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objAdd(std::shared_ptr<Object> o, std::string s) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag != \"string\") {\n		std::cerr<<\"RUNTIME ERROR: plus operation with no string type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = boost::any_cast<std::string>(o->value) + s;\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objAdd(std::shared_ptr<Object> o, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag == r->tag && o->tag == \"string\") {\n		ret->value = boost::any_cast<std::string>(o->value) + boost::any_cast<std::string>(r->value);\n		return ret;\n	}\n	else if(o->tag == r->tag && o->tag == \"double\") {\n		ret->value = boost::any_cast<double>(o->value) + boost::any_cast<double>(r->value);\n		return ret;\n	}\n	std::cerr<<\"RUNTIME ERROR: plus operation with no illegal type\"<<std::endl;\n	return nullptr;\n}\n\nstatic std::shared_ptr<Object> objAdd(double i, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = r->tag;\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = boost::any_cast<double>(r->value) + i;\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objAdd(std::string s, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = r->tag;\n	if(r->tag != \"string\") {\n		std::cerr<<\"RUNTIME ERROR: plus operation with no string type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = boost::any_cast<std::string>(r->value) + s;\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objAdd(double i, double r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->value = r + i;\n	ret->tag = \"double\";\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objAdd(std::string i, std::string r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->value = i + r;\n	ret->tag = \"string\";\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objSub(std::shared_ptr<Object> o, double i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = boost::any_cast<double>(o->value) - i;\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objSub(std::shared_ptr<Object> o, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag == r->tag && o->tag == \"double\") {\n		ret->value = boost::any_cast<double>(o->value) - boost::any_cast<double>(r->value);\n		return ret;\n	}\n	std::cerr<<\"RUNTIME ERROR: plus operation with no illegal type\"<<std::endl;\n	return nullptr;\n}\n\nstatic std::shared_ptr<Object> objSub(double i, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = r->tag;\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = i - boost::any_cast<double>(r->value);\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objSub(double i, double r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->value = i - r;\n	ret->tag = \"double\";\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objMul(std::shared_ptr<Object> o, double i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = i * boost::any_cast<double>(o->value);\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objMul(std::shared_ptr<Object> o, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag == r->tag && o->tag == \"double\") {\n		ret->value = boost::any_cast<double>(r->value) * boost::any_cast<double>(o->value);\n		return ret;\n	}\n	std::cerr<<\"RUNTIME ERROR: plus operation with no illegal type\"<<std::endl;\n	return nullptr;\n}\n\nstatic std::shared_ptr<Object> objMul(double i, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = r->tag;\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = i * boost::any_cast<double>(r->value);\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objMul(double i, double r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->value = i * r;\n	ret->tag = \"double\";\n	return ret;\n}\n\n\nstatic std::shared_ptr<Object> objDiv(std::shared_ptr<Object> o, double i) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(o->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = i / boost::any_cast<double>(o->value);\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objDiv(std::shared_ptr<Object> o, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = o->tag;\n	if(r->tag == o->tag && o->tag == \"double\") {\n		ret->value = boost::any_cast<double>(o->value) / boost::any_cast<double>(r->value);\n		return ret;\n	}\n	std::cerr<<\"RUNTIME ERROR: plus operation with no illegal type\"<<std::endl;\n	return nullptr;\n}\n\nstatic std::shared_ptr<Object> objDiv(double i, std::shared_ptr<Object> r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->tag = r->tag;\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: math operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	ret->value = i / boost::any_cast<double>(r->value);\n	return ret;\n}\n\nstatic std::shared_ptr<Object> objDiv(double i, double r) {\n	std::shared_ptr<Object> ret = std::make_shared<Object>();\n	ret->value = i / r;\n	ret->tag = \"double\";\n	return ret;\n}\n\nstatic bool objIsLarger(std::shared_ptr<Object> r, double d) {\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: cmp operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<double>(r->value) > d;\n}\n\nstatic bool objIsLarger(double d, std::shared_ptr<Object> r) {\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: cmp operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return d > boost::any_cast<double>(r->value);\n}\n\nstatic bool objIsLarger(std::shared_ptr<Object> l, std::shared_ptr<Object> r) {\n	if(r->tag != \"double\" || l->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: cmp operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<double>(l->value) > boost::any_cast<double>(r->value);\n}\n\nstatic bool objIsLarger(double r, double d) {\n	return r > d;\n}\n\nstatic bool objAnd(std::shared_ptr<Object> r, bool d) {\n	if(r->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<bool>(r->value) && d;\n}\n\nstatic bool objAnd(bool d, std::shared_ptr<Object> r) {\n	if(r->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return d && boost::any_cast<bool>(r->value);\n}\n\nstatic bool objAnd(std::shared_ptr<Object> l, std::shared_ptr<Object> r) {\n	if(r->tag != \"bool\" || l->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<bool>(l->value) && boost::any_cast<bool>(r->value);\n}\n\nstatic bool objAnd(bool r, bool d) {\n	return r && d;\n}\n\nstatic bool objOr(std::shared_ptr<Object> r, bool d) {\n	if(r->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<bool>(r->value) || d;\n}\n\nstatic bool objOr(bool d, std::shared_ptr<Object> r) {\n	if(r->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return d || boost::any_cast<bool>(r->value);\n}\n\nstatic bool objOr(std::shared_ptr<Object> l, std::shared_ptr<Object> r) {\n	if(r->tag != \"bool\" || l->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<bool>(l->value) || boost::any_cast<bool>(r->value);\n}\n\nstatic bool objOr(bool r, bool d) {\n	return r || d;\n}\n\nstatic bool objNot(bool r) {\n	return !r;\n}\n\nstatic bool objNot(std::shared_ptr<Object> r) {\n	if(r->tag != \"bool\") {\n		std::cerr<<\"RUNTIME ERROR: bool operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return !boost::any_cast<bool>(r->value);\n}\n\nstatic bool objIsSmaller(std::shared_ptr<Object> r, double d) {\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: cmp operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<double>(r->value) < d;\n}\n\nstatic bool objIsSmaller(double d, std::shared_ptr<Object> r) {\n	if(r->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: cmp operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return d < boost::any_cast<double>(r->value);\n}\n\nstatic bool objIsSmaller(std::shared_ptr<Object> l, std::shared_ptr<Object> r) {\n	if(r->tag != \"double\" || l->tag != \"double\") {\n		std::cerr<<\"RUNTIME ERROR: cmp operation with no double type\"<<std::endl;\n		return nullptr;\n	}\n	return boost::any_cast<double>(l->value) < boost::any_cast<double>(r->value);\n}\n\nstatic bool objIsSmaller(double r, double d) {\n	return r < d;\n}\n\nstatic bool objIsEqual(std::shared_ptr<Object> r, bool b) {\n	if(r->tag == \"bool\") {\n		return b == boost::any_cast<bool>(r->value);\n	}\n	return false;\n}\n\nstatic bool objIsEqual(std::shared_ptr<Object> r, double d) {\n	if(r->tag == \"double\") {\n		return d == boost::any_cast<double>(r->value);\n	}\n	return false;\n}\n\nstatic bool objIsEqual(std::shared_ptr<Object> r, std::string s) {\n	if(r->tag == \"string\") {\n		return s == boost::any_cast<std::string>(r->value);\n	}\n	return false;\n}\n\nstatic bool objIsEqual(bool b, std::shared_ptr<Object> r) {\n	if(r->tag == \"bool\") {\n		return b == boost::any_cast<bool>(r->value);\n	}\n	return false;\n}\n\nstatic bool objIsEqual(double d, std::shared_ptr<Object> r) {\n	if(r->tag == \"double\") {\n		return d == boost::any_cast<double>(r->value);\n	}\n	return false;\n}\n\nstatic bool objIsEqual(std::string s, std::shared_ptr<Object> r) {\n	if(r->tag == \"string\") {\n		return s == boost::any_cast<std::string>(r->value);\n	}\n	return false;\n}\n\nstatic bool objIsEqual(std::shared_ptr<Object> l, std::shared_ptr<Object> r) {\n	if(l->tag != r->tag) {\n		return false;\n	}\n\n	if(l->tag == \"undefined\") {\n		return true;\n	}\n	else if(l->tag == \"bool\") {\n		return boost::any_cast<bool>(l->value) == boost::any_cast<bool>(r->value);\n	}\n	else if(l->tag == \"double\") {\n		return boost::any_cast<double>(l->value) == boost::any_cast<double>(r->value);\n	}\n	else if(l->tag == \"string\") {\n		return boost::any_cast<std::string>(l->value) == boost::any_cast<std::string>(r->value);\n	}\n	else if(l->tag == \"Function\") {\n		return l->functionID == r->functionID;\n	}\n	else if(l->tag == \"list\") {\n		if(l->list.size() != r->list.size()) {\n			return false;\n		}\n		bool isequal = true;\n		for (int i = 0; i < l->list.size(); ++i)\n		{\n			isequal = objIsEqual(l->list[i], r->list[i]);\n			if(isequal == false) {\n				return false;\n			}\n		}\n		return true;\n	}\n	else if(l->tag == \"disc\") {\n		if(l->__proto__ != r->__proto__) {\n			return false;\n		}\n		else if(l->member.size() != r->member.size()) {\n			return false;\n		}\n		bool isequal = true;\n		for (auto const& x: l->member)\n		{\n			try {\n				return objIsEqual(x.second, r->member.at(x.first));\n			}\n			catch(...)\n			{\n				return false;\n			}\n		}\n		return true;\n	}\n	return false;\n}\n\ntemplate<typename L, typename R>\nstatic bool objIsEqual(L l, R r) {\n	return (l == r);\n}\n\ntemplate<typename L, typename R>\nstatic bool objIsInEqual(L l, R r) {\n	return !(objIsEqual(l, r));\n}\n\nvoid objPrint(std::string o, bool inLine = true) {\n	std::cout<<o;\n	if(inLine) {\n		std::cout<<std::endl;\n	}\n}\n\nvoid objPrint(double o, bool inLine = true) {\n	std::cout<<o;\n	if(inLine) {\n		std::cout<<std::endl;\n	}\n}\n\nvoid objPrint(bool o, bool inLine = true) {\n	std::cout<<std::boolalpha<<o;\n	if(inLine) {\n		std::cout<<std::endl;\n	}\n}\n\nvoid objPrint(const std::shared_ptr<Object>& o, bool inLine = true) {\n	if(o->tag == \"undefined\") {\n		std::cout<<\" undefined \";\n	}\n	else if(o->tag == \"disc\") {\n		std::cout<<\" { \";\n		for (auto const& x: o->member)\n		{\n			std::cout<<x.first<<\":\";\n			objPrint(x.second, false);\n			std::cout<<\"  \";\n		}\n		std::cout<<\" } \";\n	}\n	else if(o->tag == \"list\") {\n		std::cout<<\" [ \";\n		for (auto const& x: o->list)\n		{\n			objPrint(x, false);\n		}\n		std::cout<<\" ] \";\n	}\n	else if(o->tag == \"Function\") {\n		std::cout<<\" Function \";\n	}\n	else if(o->tag == \"string\") {\n		std::cout<<boost::any_cast<std::string>(o->value)<<\" \";\n	}\n	else if(o->tag == \"double\") {\n		std::cout<<boost::any_cast<double>(o->value)<<\" \";\n	}\n	else if(o->tag == \"bool\") {\n		std::cout<<std::boolalpha<<boost::any_cast<bool>(o->value)<<\" \";\n	}\n	if(inLine) {\n		std::cout<<std::endl;\n	}\n}\n";
std::string footer = "int main(int argc, char const *argv[]) {\nstd::shared_ptr<__window__> window = std::make_shared<__window__>();\nwindow->apply(window);\nreturn 0;\n}\n";

int main(int argc, char const *argv[])
{
	miniir::IRTree irtree;
	miniparser::AST::printASTTree(irtree.getIRTree());
	miniir::IRGen irgen;
	irgen.generateIR(irtree.getIRTree());
	std::cout<<header<<stabs<<irgen.getIRCode()<<footer<<std::endl;
	return 0;
}
